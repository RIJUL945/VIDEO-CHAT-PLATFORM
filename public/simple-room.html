<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Video Chat Room</title>
    <link rel="stylesheet" href="room.css">
</head>
<body>
    <div class="room-container">
        <!-- Header -->
        <header class="room-header">
            <h1>üé• Video Chat Room</h1>
            <div class="room-info">
                <span id="roomId">Room: Loading...</span>
                <span id="participantCount">üë• 0/10</span>
            </div>
        </header>

        <!-- Main Content -->
        <div class="main-content">
            <!-- Video Section -->
            <div class="video-section">
                <div id="videoGrid" class="video-grid">
                    <!-- Videos will be added here dynamically -->
                </div>
                
                <!-- Media Controls -->
                <div class="media-controls">
                    <button id="toggleVideo" class="control-btn video-on">
                        üìπ Video
                    </button>
                    <button id="toggleAudio" class="control-btn audio-on">
                        üé§ Audio
                    </button>
                    <button id="shareScreen" class="control-btn">
                        üñ•Ô∏è Share Screen
                    </button>
                    <button id="leaveRoom" class="control-btn leave-btn">
                        üö™ Leave Room
                    </button>
                </div>
            </div>

            <!-- Chat Section -->
            <div class="chat-section">
                <div class="chat-header">
                    <h3>üí¨ Chat</h3>
                    <div id="participantsList" class="participants-list">
                        <h4>Participants:</h4>
                        <div id="participants"></div>
                    </div>
                </div>
                
                <div id="chatMessages" class="chat-messages">
                    <!-- Chat messages will appear here -->
                </div>
                
                <div class="chat-input">
                    <input type="text" id="messageInput" placeholder="Type your message..." maxlength="500">
                    <button id="sendMessage">Send</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Join Modal -->
    <div id="joinModal" class="modal">
        <div class="modal-content">
            <h2>Join Video Chat Room</h2>
            <div class="modal-body">
                <input type="text" id="userNameInput" placeholder="Enter your name" maxlength="50">
                <button id="joinRoomBtn">Join Room</button>
            </div>
        </div>
    </div>

    <!-- Scripts -->
    <script src="/socket.io/socket.io.js"></script>
    <script>
        // Global variables
        const socket = io();
        let localStream = null;
        let peerConnections = {};
        let roomId = null;
        let userName = null;
        let isVideoEnabled = true;
        let isAudioEnabled = true;

        // WebRTC Configuration
        const rtcConfig = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' },
                { urls: 'stun:stun2.l.google.com:19302' }
            ]
        };

        // DOM Elements
        const joinModal = document.getElementById('joinModal');
        const userNameInput = document.getElementById('userNameInput');
        const joinRoomBtn = document.getElementById('joinRoomBtn');
        const videoGrid = document.getElementById('videoGrid');
        const toggleVideoBtn = document.getElementById('toggleVideo');
        const toggleAudioBtn = document.getElementById('toggleAudio');
        const shareScreenBtn = document.getElementById('shareScreen');
        const leaveRoomBtn = document.getElementById('leaveRoom');
        const chatMessages = document.getElementById('chatMessages');
        const messageInput = document.getElementById('messageInput');
        const sendMessageBtn = document.getElementById('sendMessage');
        const participantsDiv = document.getElementById('participants');
        const roomIdSpan = document.getElementById('roomId');
        const participantCountSpan = document.getElementById('participantCount');

        // Initialize room
        async function initializeRoom() {
            // Get room ID from URL
            roomId = window.location.pathname.split('/').pop();
            roomIdSpan.textContent = `Room: ${roomId}`;
            
            // Show join modal
            joinModal.style.display = 'flex';
            
            // Focus on name input
            userNameInput.focus();
        }

        // Get user media
        async function getUserMedia() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                
                console.log('Got local stream');
                return localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Could not access camera/microphone. Please check permissions.');
                return null;
            }
        }

        // Join room
        async function joinRoom() {
            userName = userNameInput.value.trim();
            if (!userName) {
                alert('Please enter your name');
                return;
            }

            // Get user media first
            const stream = await getUserMedia();
            if (!stream) return;

            // Add local video
            addVideoElement('local', stream, userName, true);

            // Join room via socket
            socket.emit('join-room', { roomId, userName });

            // Hide modal
            joinModal.style.display = 'none';
        }

        // Create peer connection
        function createPeerConnection(peerId, peerName, isInitiator = false) {
            console.log(`Creating peer connection for ${peerName} (${peerId}), initiator: ${isInitiator}`);
            
            const pc = new RTCPeerConnection(rtcConfig);
            
            // Add local stream to peer connection
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                    console.log('Added local track to peer connection');
                });
            }

            // Handle remote stream
            pc.ontrack = (event) => {
                console.log(`Received remote stream from ${peerName}`);
                const remoteStream = event.streams[0];
                addVideoElement(peerId, remoteStream, peerName, false);
            };

            // Handle ICE candidates
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate to', peerId);
                    socket.emit('ice-candidate', {
                        target: peerId,
                        candidate: event.candidate
                    });
                }
            };

            // Handle connection state changes
            pc.onconnectionstatechange = () => {
                console.log(`Connection state with ${peerName}: ${pc.connectionState}`);
                if (pc.connectionState === 'failed' || pc.connectionState === 'disconnected') {
                    console.log(`Connection failed with ${peerName}, attempting to reconnect...`);
                }
            };

            peerConnections[peerId] = pc;

            // Create offer if initiator
            if (isInitiator) {
                createOffer(peerId);
            }

            return pc;
        }

        // Create and send offer
        async function createOffer(peerId) {
            const pc = peerConnections[peerId];
            if (!pc) return;

            try {
                const offer = await pc.createOffer();
                await pc.setLocalDescription(offer);
                
                console.log('Sending offer to', peerId);
                socket.emit('offer', {
                    target: peerId,
                    offer: offer
                });
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        }

        // Add video element to grid
        function addVideoElement(id, stream, name, isLocal = false) {
            console.log(`Adding video element for ${name} (${id})`);
            
            // Remove existing element if any
            removeVideoElement(id);
            
            const videoContainer = document.createElement('div');
            videoContainer.className = 'video-container';
            videoContainer.id = `video-${id}`;
            
            // Create video element
            const video = document.createElement('video');
            video.className = 'video-element';
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            video.muted = isLocal; // Mute local video to prevent echo
            
            // Create name label
            const nameLabel = document.createElement('div');
            nameLabel.className = 'video-name';
            nameLabel.textContent = name + (isLocal ? ' (You)' : '');
            
            videoContainer.appendChild(video);
            videoContainer.appendChild(nameLabel);
            videoGrid.appendChild(videoContainer);
            
            console.log(`Video element added for ${name}`);
        }

        // Remove video element
        function removeVideoElement(id) {
            const existingElement = document.getElementById(`video-${id}`);
            if (existingElement) {
                existingElement.remove();
                console.log(`Removed video element for ${id}`);
            }
        }

        // Add chat message
        function addChatMessage(message, senderName, timestamp, isOwn = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `chat-message ${isOwn ? 'own-message' : ''}`;
            
            const time = new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
            
            messageDiv.innerHTML = `
                <div class="message-header">
                    <span class="sender-name">${senderName}</span>
                    <span class="message-time">${time}</span>
                </div>
                <div class="message-content">${message}</div>
            `;
            
            chatMessages.appendChild(messageDiv);
            chatMessages.scrollTop = chatMessages.scrollHeight;
        }

        // Update participants list
        function updateParticipantsList(participants) {
            participantsDiv.innerHTML = '';
            participants.forEach(participant => {
                const participantDiv = document.createElement('div');
                participantDiv.className = 'participant';
                participantDiv.textContent = participant.userName;
                participantsDiv.appendChild(participantDiv);
            });
        }

        // Socket event handlers
        socket.on('room-joined', (data) => {
            console.log('Joined room:', data.roomId);
            console.log('Current participants:', data.participants);
            
            // Update UI
            participantCountSpan.textContent = `üë• ${data.participants.length}/${data.maxCapacity}`;
            updateParticipantsList(data.participants);
            
            // Create peer connections for existing participants (excluding self)
            data.participants.forEach(participant => {
                if (participant.socketId !== socket.id) {
                    createPeerConnection(participant.socketId, participant.userName, true);
                }
            });
        });

        socket.on('user-joined', (participant) => {
            console.log('User joined:', participant.userName);
            
            // Create peer connection for new user (not initiator)
            createPeerConnection(participant.socketId, participant.userName, false);
            
            // Add chat notification
            addChatMessage(`${participant.userName} joined the room`, 'System', new Date());
        });

        socket.on('user-left', (userData) => {
            console.log('User left:', userData.userName);
            
            // Clean up peer connection
            if (peerConnections[userData.socketId]) {
                peerConnections[userData.socketId].close();
                delete peerConnections[userData.socketId];
            }
            
            // Remove video element
            removeVideoElement(userData.socketId);
            
            // Add chat notification
            addChatMessage(`${userData.userName} left the room`, 'System', new Date());
        });

        socket.on('offer', async (data) => {
            console.log('Received offer from:', data.senderName);
            
            const pc = peerConnections[data.sender];
            if (!pc) {
                console.error('No peer connection found for', data.sender);
                return;
            }

            try {
                await pc.setRemoteDescription(data.offer);
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);
                
                console.log('Sending answer to:', data.sender);
                socket.emit('answer', {
                    target: data.sender,
                    answer: answer
                });
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        });

        socket.on('answer', async (data) => {
            console.log('Received answer from:', data.senderName);
            
            const pc = peerConnections[data.sender];
            if (!pc) {
                console.error('No peer connection found for', data.sender);
                return;
            }

            try {
                await pc.setRemoteDescription(data.answer);
                console.log('Set remote description from answer');
            } catch (error) {
                console.error('Error handling answer:', error);
            }
        });

        socket.on('ice-candidate', async (data) => {
            console.log('Received ICE candidate from:', data.sender);
            
            const pc = peerConnections[data.sender];
            if (!pc) {
                console.error('No peer connection found for', data.sender);
                return;
            }

            try {
                await pc.addIceCandidate(data.candidate);
                console.log('Added ICE candidate');
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        });

        socket.on('chat-message', (data) => {
            const isOwn = data.socketId === socket.id;
            addChatMessage(data.message, data.userName, data.timestamp, isOwn);
        });

        socket.on('participant-count-update', (data) => {
            participantCountSpan.textContent = `üë• ${data.count}/${data.maxCapacity}`;
        });

        socket.on('error', (message) => {
            alert(`Error: ${message}`);
            window.location.href = '/';
        });

        // Media control handlers
        toggleVideoBtn.addEventListener('click', () => {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    isVideoEnabled = videoTrack.enabled;
                    toggleVideoBtn.textContent = isVideoEnabled ? 'üìπ Video' : 'üìπ Video (Off)';
                    toggleVideoBtn.className = `control-btn ${isVideoEnabled ? 'video-on' : 'video-off'}`;
                }
            }
        });

        toggleAudioBtn.addEventListener('click', () => {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    isAudioEnabled = audioTrack.enabled;
                    toggleAudioBtn.textContent = isAudioEnabled ? 'üé§ Audio' : 'üé§ Audio (Off)';
                    toggleAudioBtn.className = `control-btn ${isAudioEnabled ? 'audio-on' : 'audio-off'}`;
                }
            }
        });

        shareScreenBtn.addEventListener('click', async () => {
            try {
                const screenStream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: true
                });
                
                // Replace video track in all peer connections
                const videoTrack = screenStream.getVideoTracks()[0];
                Object.values(peerConnections).forEach(pc => {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender) {
                        sender.replaceTrack(videoTrack);
                    }
                });
                
                // Update local video
                const localVideo = document.querySelector('#video-local video');
                if (localVideo) {
                    localVideo.srcObject = screenStream;
                }
                
                // Handle screen share end
                videoTrack.onended = () => {
                    getUserMedia().then(stream => {
                        const videoTrack = stream.getVideoTracks()[0];
                        Object.values(peerConnections).forEach(pc => {
                            const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender) {
                                sender.replaceTrack(videoTrack);
                            }
                        });
                        
                        const localVideo = document.querySelector('#video-local video');
                        if (localVideo) {
                            localVideo.srcObject = stream;
                        }
                    });
                };
            } catch (error) {
                console.error('Error sharing screen:', error);
                alert('Could not share screen. Please try again.');
            }
        });

        leaveRoomBtn.addEventListener('click', () => {
            if (confirm('Are you sure you want to leave the room?')) {
                // Close all peer connections
                Object.values(peerConnections).forEach(pc => pc.close());
                
                // Stop local stream
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Redirect to home
                window.location.href = '/';
            }
        });

        // Chat functionality
        function sendMessage() {
            const message = messageInput.value.trim();
            if (message && roomId && userName) {
                socket.emit('chat-message', {
                    roomId: roomId,
                    message: message,
                    userName: userName
                });
                messageInput.value = '';
            }
        }

        sendMessageBtn.addEventListener('click', sendMessage);
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            }
        });

        // Join room functionality
        joinRoomBtn.addEventListener('click', joinRoom);
        userNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                joinRoom();
            }
        });

        // Initialize when page loads
        document.addEventListener('DOMContentLoaded', initializeRoom);

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            Object.values(peerConnections).forEach(pc => pc.close());
        });
    </script>
</body>
</html>
